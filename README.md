## Rust

---

#### 序章

1. 实现函数简单调用

2. 实现服务器应用

3. 实现曼德博集合

4. 实现文件读取、写入、替换、删除

---

#### 第一章

##### 1. 基本数据类型

类型推断机制，只需要表明返回值的类型，即可让函数体内的变量默认获取该类型

###### 1.1 数据类型

| 数据名称    | 表示形式                | 备注            |
| ------- | ------------------- | ------------- |
| 无符号整型   | u8,u16:0~2^16-1     | 范围从0开始        |
| 有符号整型   | i8,i16:-2^15~2^15-1 |               |
| 单精度浮点类型 | f32                 |               |
| 双精度浮点类型 | f64                 |               |
| 布尔类型    | true,false          |               |
| 字符类型    | 'a','\u{CA0}'       | 多种表示方法，表示单个字符 |
| 元组类型    | (a,b,c,...)         | 特殊表达：单元类型 ()  |

> 数据类型必须先明确，再使用
> 
> 布尔类型的数据类型转换只能有 布尔类型转换为整型数值

##### 1.2 数据运算

- 检查运算

数学意义上的结果可以表示为该类型的值，那么与`Some(v)`匹配，否则为`None`

- 回绕运算

数学意义上的结果与值类型范围取值相等的结果

可能会发生溢出的情况，然后会不断在数值范围内循环，最终经过几次循环之后，得到一个范围里的值与计算结果匹配

- 饱和运算

返回一个最接近数学意义上的结果

可能计算的结果会超过数值范围，所以得到一个数值范围内的最大值来表达计算结果值

- 溢出运算

返回一个元组（溢出结果值，是否溢出的布尔值）

##### 1.3 指针

总结指针的三种类型

- 引用

Rust中的引用不会为空，存在两种使用方式

第一种是共享引用，表达式为`&T`，它可以表示多个值的引用，只能读取，不能修改

第二种是独占引用，表达式为`&mut T`,它只能表示对一个值的引用，可以读取、可以修改

- Box(堆)

表示为元组在堆中分配一个空间，如果空间超出作用域，则会立即释放该空间。

使用示例：

```rust
let a = (213,"hdsk3");
let box = Box::new(a);    // 为a分配一个堆空间
```

- 裸指针

Rust中指向为空、指向已释放的内存，或者指向现在包含不同类型的值，**不安全**

只能在`unsafe`模块里解除引用

指针类型`*mut T`,`*const T`

##### 1.4 数组

- 数组

    数组在定义时已经将类型及长度确认，即类型不可更改、长度不可扩展

数组的定义方法

```rust
let lazy_caterer: [u32; 6] = [1, 2, 3, 4, 5, 6];
let taxonomy = ["Animalia", "Arthropod", "Insect"];
```

- 向量

向量的数据存放在对当中，本身的空间里存放指针、长度数据，长度可以扩展，能够实现删除、修改等操作

向量的定义方法

```rust
let mut primes = Vec::new() // 生成一个空向量
let mut primes1 = vec![1,2,3,4] // 生成有数值的向量

v.len(); // 获取数据长度
v.capacity(); // 获取容量长度
v.push(3); // 数据入栈
v.insert(3, 35); // 插入数据
v.remove(1); // 删除数据，提供数据下标
v.pop(); // 数据出栈
```

> `reverse(),sort()`等等切片方法都可以在数组身上使用，因为在数组使用这些方法的时候，会生成一个对数组引用的切片

- 切片

切片是一个指针，总是指向数组或向量的起始位置，实现对数组或向量的引用

切片的定义

```rust
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
let a: [f64; 4] = [0.0, -0.707, -1.0, -0.707];

let sv: &[f64] = &v; // 切片对数组的引用
let sa: &[f64] = &a; // 切片对向量的引用
```

对切片的简单使用

```rust
print(&v[0..2]);
print(&a[2..]);
print(&sv[1..3]);
```
